<!doctype html>
<meta charset="utf-8">
<title>Collision detection</title>
<body>
<script src="../pixi/pixi.min.js"></script>
<script>

//Aliases
let Application = PIXI.Application,
    Container = PIXI.Container,
    loader = PIXI.loader,
    resources = PIXI.loader.resources,
    Graphics = PIXI.Graphics,
    TextureCache = PIXI.utils.TextureCache,
    Sprite = PIXI.Sprite,
    Text = PIXI.Text,
    TextStyle = PIXI.TextStyle;

//Create a Pixi Application
let app = new Application({
    width: 1920,
    height: 1080,
    antialiasing: true,
    transparent: false,
    resolution: 1
  }
);

//Add the canvas that Pixi automatically created for you to the HTML document
document.body.appendChild(app.view);

loader
  .add("images/BG_empty.png")
  .add("images/messy_hair.png")
  .add("images/nice_hair.png")
  .add("images/comb_short.png")
  .add("images/knot_1.png")
  .add("images/knot_2.png")
  .add("images/Warning-yellow.png")
  .add("images/Warning-orange.png")
  .add("images/Warning-red.png")
  .add("images/cat.png")
  .load(setup);

//Define any variables that are used in more than one function
let mode, cat, comb_short, back, box, message, state, tilingSprite, knot_1, knot_2, Warning_yellow, Warning_orange, Warning_red;

// create a texture from an image path
const textureMessyHair = PIXI.Texture.from('images/messy_hair.png');


let count = 0;

function setup() {
  mode = 'normal';
  //Create the box
  box = new PIXI.Graphics();
  box.beginFill(0xCCFF99);
  box.drawRect(0, 0, 64, 64);
  box.endFill();
  box.x = 120;
  box.y = 96;
  app.stage.addChild(box);

  //Create the `BG` sprite
  back = new Sprite(resources["images/BG_empty.png"].texture);
  back.x = 0;
  back.y = 0;
  back.vx = 0;
  back.vy = 0;
  app.stage.addChild(back);

  //Create the `messy_hair` sprite
  messy_hair = new Sprite(resources["images/messy_hair.png"].texture);
  messy_hair.x = 540;
  messy_hair.y = 370;
  messy_hair.vx = 0;
  messy_hair.vy = 0;
  //app.stage.addChild(messy_hair);
  tilingSpriteMessyHair = new PIXI.TilingSprite(
    textureMessyHair,
    971,
    1080,
);
  tilingSpriteMessyHair.x=540;
  tilingSpriteMessyHair.y=370;
  app.stage.addChild(tilingSpriteMessyHair);

  //Create the `nice_hair` sprite
  nice_hair = new Sprite(resources["images/nice_hair.png"].texture);
  nice_hair.x = 540;
  nice_hair.y = 370-1080;
  nice_hair.vx = 0;
  nice_hair.vy = 0;
  app.stage.addChild(nice_hair);

  //Create the `comb_short` sprite
  comb_short = new Sprite(resources["images/comb_short.png"].texture);
  comb_short.x = 521;
  comb_short.y = 176;
  comb_short.vx = 0;
  comb_short.vy = 0;
  app.stage.addChild(comb_short);

  //Create the `cat` sprite
  cat = new Sprite(resources["images/cat.png"].texture);
  cat.x = 16;
  cat.y = 96;
  cat.vx = 0;
  cat.vy = 0;
  app.stage.addChild(cat);

  //Create the `knot_1` sprite
  knot_1 = new Sprite(resources["images/knot_1.png"].texture);
  knot_1.x = 700;
  knot_1.y = 1080;
  knot_1.vx = 0;
  knot_1.vy = 0;
  app.stage.addChild(knot_1);

  //Create the `knot_2` sprite
  knot_2 = new Sprite(resources["images/knot_2.png"].texture);
  knot_2.x = 850;
  knot_2.y = 1280;
  knot_2.vx = 0;
  knot_2.vy = 0;
  app.stage.addChild(knot_2);

  //Create the `Warning_yellow` sprite
  Warning_yellow = new Sprite(resources["images/Warning-yellow.png"].texture);
  Warning_yellow.x = 480;
  Warning_yellow.y = 1080;
  Warning_yellow.vx = 0;
  Warning_yellow.vy = 0;
  app.stage.addChild(Warning_yellow);

  //Create the `Warning_orange` sprite
  Warning_orange = new Sprite(resources["images/Warning-orange.png"].texture);
  Warning_orange.x = 480;
  Warning_orange.y = 1080;
  Warning_orange.vx = 0;
  Warning_orange.vy = 0;
  app.stage.addChild(Warning_orange);

  //Create the `Warning_red` sprite
  Warning_red = new Sprite(resources["images/Warning-red.png"].texture);
  Warning_red.x = 480;
  Warning_red.y = 1080;
  Warning_red.vx = 0;
  Warning_red.vy = 0;
  app.stage.addChild(Warning_red);

  //Capture the keyboard arrow keys
  let left = keyboard(37),
      up = keyboard(38),
      right = keyboard(39),
      down = keyboard(40);

  //Left arrow key `press` method
  left.press = function() {

    //Change the cat's velocity when the key is pressed
    cat.vx = -5;
    cat.vy = 0;
  };

  //Left arrow key `release` method
  left.release = function() {

    //If the left arrow has been released, and the right arrow isn't down,
    //and the cat isn't moving vertically:
    //Stop the cat
    if (!right.isDown && cat.vy === 0) {
      cat.vx = 0;
    }
  };

  //Up
  up.press = function() {
    cat.vy = -5;
    cat.vx = 0;
  };
  up.release = function() {
    if (!down.isDown && cat.vx === 0) {
      cat.vy = 0;
    }
  };

  //Right
  right.press = function() {
    cat.vx = 5;
    cat.vy = 0;
  };
  right.release = function() {
    if (!left.isDown && cat.vy === 0) {
      cat.vx = 0;
    }
  };

  //Down
  down.press = function() {
    cat.vy = 5;
    cat.vx = 0;
  };
  down.release = function() {
    if (!up.isDown && cat.vx === 0) {
      cat.vy = 0;
    }
  };

  //Create the text sprite
  let style = new TextStyle({
    fontFamily: "sans-serif",
    fontSize: 18,
    fill: "white",
  });
  message = new Text("No collision... ("+cat.x+", "+cat.y+")", style);
  message.position.set(8, 8);
  app.stage.addChild(message);

  //Set the game state
  state = play;

  //Start the game loop
  app.ticker.add(delta => gameLoop(delta));
}


function gameLoop(delta){

  //Update the current game state:
  state(delta);
}

function play(delta) {
  let speedMultiplier = 1;
  let normalSpeed = 5*speedMultiplier;
  let recoverSpeed = 1*speedMultiplier;
  let dangerSpeed = 1*speedMultiplier;
  let moveSpeed = mode === 'danger' ? dangerSpeed : normalSpeed;

  // evolution
  switch (mode) {
        case 'normal':
        if(knot_1.y <= tilingSpriteMessyHair.y || knot_2.y <= tilingSpriteMessyHair.y) {
            mode = 'danger';
        }
        break;
        case 'danger':
        if(knot_1.y > tilingSpriteMessyHair.y && knot_2.y > tilingSpriteMessyHair.y) {
            mode = 'recover';
        }
        break;
        case 'recover':
        if(knot_1.y <= tilingSpriteMessyHair.y || knot_2.y <= tilingSpriteMessyHair.y) {
            mode = 'danger';
        }
        if(370 <= tilingSpriteMessyHair.y) {
            mode = 'normal';
            tilingSpriteMessyHair.y = 370;
            nice_hair.y = 370-1080;
            comb_short.y=176;
        }
        break;
  }

  // action
  switch (mode) {
        case 'normal':
        tilingSpriteMessyHair.tilePosition.vy = -moveSpeed;
        tilingSpriteMessyHair.vy = 0;
        comb_short.vy=0;
        Warning_yellow.y = 1080;
        Warning_orange.y = 1080;
        Warning_red.y = 1080;
        break;
        case 'danger':
        tilingSpriteMessyHair.tilePosition.vy = 0;
        tilingSpriteMessyHair.vy = -moveSpeed;
        Warning_yellow.y = 0;
        Warning_orange.y = Warning_yellow.y == 0  ? 1080-Warning_orange.y : 1080;
        Warning_red.y = Warning_orange.y == 0  ? 1080-Warning_red.y : 1080;
        break;
        case 'recover':
        tilingSpriteMessyHair.tilePosition.vy = -moveSpeed;
        tilingSpriteMessyHair.vy = recoverSpeed;
        Warning_yellow.y = 1080;
        Warning_orange.y = 1080;
        Warning_red.y = 1080;

        break;
  }


  if(knot_1.y <= 10) {
    knot_1.y = 2580;
  }


  if(knot_2.y <= 10) {
    knot_2.y = 2780;
  }

  //use the cat's velocity to make it move
  cat.x += cat.vx;
  cat.y += cat.vy;
  tilingSpriteMessyHair.tilePosition.y += tilingSpriteMessyHair.tilePosition.vy;
  tilingSpriteMessyHair.y += tilingSpriteMessyHair.vy;
  comb_short.y += tilingSpriteMessyHair.vy;
  nice_hair.y += tilingSpriteMessyHair.vy;
  knot_1.y -= moveSpeed;
  knot_2.y -= moveSpeed;

  //check for a collision between the cat and the box
  if (hitTestRectangle(cat, box)) {

    //if there's a collision, change the message text
    //and tint the box red
    message.text = "hit!";
    box.tint = 0xff3300;
  } else {

    //if there's no collision, reset the message
    //text and the box's color
    message.text = "No collision...("+cat.x+", "+cat.y+")";
    box.tint = 0xccff99;
  }
}

//The `hitTestRectangle` function
function hitTestRectangle(r1, r2) {

  //Define the variables we'll need to calculate
  let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

  //hit will determine whether there's a collision
  hit = false;

  //Find the center points of each sprite
  r1.centerX = r1.x + r1.width / 2;
  r1.centerY = r1.y + r1.height / 2;
  r2.centerX = r2.x + r2.width / 2;
  r2.centerY = r2.y + r2.height / 2;

  //Find the half-widths and half-heights of each sprite
  r1.halfWidth = r1.width / 2;
  r1.halfHeight = r1.height / 2;
  r2.halfWidth = r2.width / 2;
  r2.halfHeight = r2.height / 2;

  //Calculate the distance vector between the sprites
  vx = r1.centerX - r2.centerX;
  vy = r1.centerY - r2.centerY;

  //Figure out the combined half-widths and half-heights
  combinedHalfWidths = r1.halfWidth + r2.halfWidth;
  combinedHalfHeights = r1.halfHeight + r2.halfHeight;

  //Check for a collision on the x axis
  if (Math.abs(vx) < combinedHalfWidths) {

    //A collision might be occurring. Check for a collision on the y axis
    if (Math.abs(vy) < combinedHalfHeights) {

      //There's definitely a collision happening
      hit = true;
    } else {

      //There's no collision on the y axis
      hit = false;
    }
  } else {

    //There's no collision on the x axis
    hit = false;
  }

  //`hit` will be either `true` or `false`
  return hit;
};


//The `keyboard` helper function
function keyboard(keyCode) {
  let key = {};
  key.code = keyCode;
  key.isDown = false;
  key.isUp = true;
  key.press = undefined;
  key.release = undefined;

  //The `downHandler`
  key.downHandler = function(event) {
    if (event.keyCode === key.code) {
      if (key.isUp && key.press) key.press();
      key.isDown = true;
      key.isUp = false;
    }
    event.preventDefault();
  };

  //The `upHandler`
  key.upHandler = function(event) {
    if (event.keyCode === key.code) {
      if (key.isDown && key.release) key.release();
      key.isDown = false;
      key.isUp = true;
    }
    event.preventDefault();
  };

  //Attach event listeners
  window.addEventListener(
    "keydown", key.downHandler.bind(key), false
  );
  window.addEventListener(
    "keyup", key.upHandler.bind(key), false
  );
  return key;
}

</script>
</body>